// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.IO;
using MeetingYourMatch.Data;
using Microsoft.Research.Glo;

namespace MeetingYourMatch
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

#if NETFULL
    using Microsoft.Research.Glo.Commands;
#endif

    using Microsoft.Research.Glo.ObjectModel;

    using MBMLViews;

    using Microsoft.ML.Probabilistic.Distributions;

    using MeetingYourMatch.Experiments;
    using MeetingYourMatch.Items;
    using MeetingYourMatch.Models;
    using MeetingYourMatch.Models.TrueSkill;
    using MeetingYourMatch.Views;
    using MBMLCommon;

#if NETFULL
    using Point = System.Windows.Point;
#else
    using Point = MBMLCommon.Point;
#endif

    /// <summary>
    /// The model runner.
    /// </summary>
    public class ModelRunner
    {
        /// <summary>
        /// The data path.
        /// </summary>
        private const string DataPath = @"Data/";

        /// <summary>
        /// The data path.
        /// </summary>
        private Outputter outputter;

        public bool ShowFactorGraph { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModelRunner"/> class.
        /// </summary>
        public ModelRunner(Outputter outputter, bool showFactorGraph)
        {
            this.outputter = outputter;
            this.ShowFactorGraph = showFactorGraph;
        }

        /// <summary>
        /// Gets or sets the variables.
        /// </summary>
        public Dictionary<string,object> LogProbs { get; set; } = new Dictionary<string,object>();

        private void AnnounceExperiment(string name)
        {
            Console.WriteLine($"Running " + name);
        }
        /// <summary>
        /// The Expectation Propagation message example.
        /// </summary>
        public void EpMessageExample()
        {
            AnnounceExperiment("EpMessageExample");

            // This version uses greater than factor
            const double Skill1 = 120;
            const double Skill2 = 100;
            const double Sigma1 = 40;
            const double Sigma2 = 5;
            const double Variance1 = Sigma1 * Sigma1;
            const double Variance2 = Sigma2 * Sigma2;
            const double Beta = 5;
            const double PerformanceVariance = Beta * Beta;

            var skill1Prior = new Gaussian(Skill1, Variance1);
            var skill2Prior = new Gaussian(Skill2, Variance2);

            var model = new TwoPlayerMessages(PerformanceVariance, skill1Prior, skill2Prior, MatchOutcome.Player1Win, ShowFactorGraph);

            var performance1 = new Gaussian(Skill1, Variance1 + PerformanceVariance);
            var performance2 = new Gaussian(Skill2, Variance2 + PerformanceVariance);

            var range = new RealRange { Min = -200, Max = 400, Steps = 300 };

            // Produce a plot of the belief propagation message, incoming message, and the two of these multiplied,
            // the projection of this onto a Gaussian, and the EP message for the message from the greater than
            // factor to Jill's performance variable
            Func<double, double> cdf = x => Utils.StandardGaussian.CumulativeDistributionFunction(x);

            // Exact message
            double mu = performance2.GetMean();
            double sigma = Math.Sqrt(performance2.GetVariance());
            Func<double, double> f = x => cdf((x - mu) / sigma) / sigma;

            // Arbitrary renormalisation so that it fits on the plot
            Func<double, double> exact = x => f(x) / 20;

            // The actual message generated by Infer.NET. This is proj[f_i(x) * q\i(x)] / q\i(x)
            var message = model.MessageHistories["JPerf_B"][0];

            // The projection proj[f_i(x) * q\i(x)]
            var proj = message * performance1;

            // f_i(x) * q\i(x)
            Func<double, double> fqnoti = x => f(x) * Math.Exp(performance1.GetLogProb(x));
            Func<double, double> ce = x => fqnoti(x) / fqnoti.Integrate(range);

            var plot = new EPMessageDemoViewModel
                           {
                               { "e (Exact)", Utils.Evaluate(exact, range) },
                               { "c (Context)", Utils.Evaluate(performance1, range) },
                               { "c e", Utils.Evaluate(ce, range) },
                               { "Proj(c e)", Utils.Evaluate(proj, range) },
                               { "Proj(c e) / c", Utils.Evaluate(message, range) }
                           };

            var bpMessageDemo = new Dictionary<string,object> { { "Summary", plot } };

            // Produce a plot of the belief propagation message, incoming message, and the two of these multiplied for 
            // Jill's skill marginal
            double sigma1Sq = performance2.GetVariance();
            Func<double, double> f1 = x => cdf((x - mu) / (sigma * Math.Sqrt(1 + (sigma1Sq / Variance1))));
            Func<double, double> f1N = x => f1(x) / 60;
            Func<double, double> fqnoti1 = x => f1(x) * Math.Exp(skill1Prior.GetLogProb(x));
            Func<double, double> fqnotin1 = x => fqnoti1(x) / fqnoti1.Integrate(range);
            message = model.MessageHistories["JSkill_marginal_F"][0];
            proj = message * skill1Prior;

            var skill1Marginal = new EPMessageDemoViewModel
                                     {
                                         { "e (Exact)", Utils.Evaluate(f1N, range) },
                                         { "c (Context)", Utils.Evaluate(skill1Prior, range) },
                                         { "c e", Utils.Evaluate(fqnotin1, range) },
                                     };

            bpMessageDemo["JSkillMarginal"] = skill1Marginal;
            bpMessageDemo["Model"] = model;

            // Null plots
            Func<int, IEnumerable<KeyValuePair<string, object>>> nullFunc =
                x => Enumerable.Range(0, x).Select(i => new KeyValuePair<string, object>(i.ToString("D"), new Point[] { }));

            // Create extra variables because we can't serialize KeyValuePair<>[]
            bpMessageDemo.Add(
                "Subplots",
                new[]
                    {
                        new EPMessageDemoViewModel { { plot.First().Key, plot.First().Value } },
                        new EPMessageDemoViewModel(plot.Take(2)),
                        new EPMessageDemoViewModel(plot.Take(3)),
                    });

            bpMessageDemo.Add(
                "JSkillMarginalSubplots",
                new[]
                    {
                        new EPMessageDemoViewModel { { skill1Marginal.First().Key, skill1Marginal.First().Value } },
                        new EPMessageDemoViewModel(skill1Marginal.Take(2)),
                        new EPMessageDemoViewModel(skill1Marginal.Take(3)),
                    });

            outputter.Out(bpMessageDemo,
                Contents.S2InferringThePlayersSkills.NumberedName,
                "The belief propagation message example");

            //Section 3

            Console.WriteLine($"\n{Contents.S3ASolutionExpectationPropagation.NumberedName}.\n");

            skill1Marginal = new EPMessageDemoViewModel
                                     {
                                         { "e (Exact)", Utils.Evaluate(f1N, range) },
                                         { "c (Context)", Utils.Evaluate(skill1Prior, range) },
                                         { "c e", Utils.Evaluate(fqnotin1, range) },
                                         { "Proj(c e)", Utils.Evaluate(proj, range) },
                                         { "Proj(c e) / c", Utils.Evaluate(message, range) }
                                     };

            var exMessageDemo = new Dictionary<string,object> { { "Summary", plot } };
            exMessageDemo["JSkillMarginal"] = skill1Marginal;
            exMessageDemo["Model"] = model;

            exMessageDemo.Add(
                "Subplots",
                new[]
                    {
                                    new EPMessageDemoViewModel { { plot.First().Key, plot.First().Value } },
                                    new EPMessageDemoViewModel(plot.Take(2)),
                                    new EPMessageDemoViewModel(plot.Take(3)),
                                    //Section 3
                                    new EPMessageDemoViewModel(nullFunc(2).Concat(plot.Skip(2).Take(2))),
                                    new EPMessageDemoViewModel(plot.Take(2).Concat(nullFunc(1).Concat(plot.Skip(3).Take(2))))
                    });

            exMessageDemo.Add(
                "JSkillMarginalSubplots",
                new[]
                    {
                                    new EPMessageDemoViewModel { { skill1Marginal.First().Key, skill1Marginal.First().Value } },
                                    new EPMessageDemoViewModel(skill1Marginal.Take(2)),
                                    new EPMessageDemoViewModel(skill1Marginal.Take(3)),
                                    // Section 3
                                    new EPMessageDemoViewModel(nullFunc(2).Concat(skill1Marginal.Skip(2).Take(2))),
                                    new EPMessageDemoViewModel(skill1Marginal.Take(2).Concat(plot.Skip(3).Take(2)))
                    });

            outputter.Out(exMessageDemo,
                Contents.S3ASolutionExpectationPropagation.NumberedName,
                "The expectation propagation message example");
        }

        /// <summary>
        /// Head to head.
        /// </summary>
        public void HeadToHead()
        {
            AnnounceExperiment("HeadToHead");

            var inputs = Halo2Fetcher.LoadByGameType<TwoPlayerGame>(Path.Combine(DataPath, "HeadToHead.csv"));

            // We know that there are issues with players Gamer01266 and Gamer00296
            inputs.Games =
                new KeyedCollectionWithFunc<string, TwoPlayerGame>(
                    inputs.Games.Where(ia => !ia.Players.Contains("Gamer01266") && !ia.Players.Contains("Gamer00296")),
                    ia => ia.Id);
            inputs.Players.Remove("Gamer01266");
            inputs.Players.Remove("Gamer00296");

            var datasetSummary = new DatasetSummary
            {
                Name = "Head to Head",
                NumberOfGames = inputs.NumberOfGames,
                NumberOfPlayers = inputs.NumberOfPlayers,
                TeamsPerGame = 2,
                PlayersPerTeam = 1,
                PlayersPerGame = 2
            };

            outputter.Out(inputs,
                Contents.S3ASolutionExpectationPropagation.NumberedName,
                "Halo2-HeadToHead",
                "Dataset"
                );

            outputter.Out(datasetSummary,
                Contents.S3ASolutionExpectationPropagation.NumberedName,
                "Halo2-HeadToHead",
                "Dataset summary");

            outputter.Out(inputs,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-HeadToHead",
                "Dataset"
                );

            outputter.Out(datasetSummary,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-HeadToHead",
                "Dataset summary");

            // Get games of top two players
            GetTopTwo(inputs, out var topTwoPlayers, out var topTwoGames);

            // Get games without draws
            var gamesWithoutDraws = inputs.Games.Where(ia => ia.Outcome != MatchOutcome.Draw).ToList();
            Console.WriteLine(@"Number of games without draws in Halo2 head to head: " + gamesWithoutDraws.Count);
            Console.WriteLine(@"Number of players in Halo2 head to head: " + inputs.Players.Count);

            var alphas = new[] { 0.07, 0.35 }.Select(ia => ia * inputs.Beta).ToArray();

            var randomParameters1 = new RandomModelParameters { IncludeDraws = false };
            var randomParameters2 =
                alphas.Select(
                    alpha =>
                    new RandomModelParameters
                    {
                        IncludeDraws = true,
                        EmpiricalDrawProportion = inputs.DrawProportion
                    }).ToArray();

            var trueSkillParameters = inputs.TrueSkillParameters;
            trueSkillParameters.DynamicsVariance = 0;

            var withoutDraws =
                new OnlineExperimentComparison<TwoPlayerGame>(
                    new OnlineExperiment(ia => new TwoPlayer(ia, ShowFactorGraph), trueSkillParameters)
                    {
                        Players = inputs.Players,
                        Priors = inputs.TrueSkillPriors,
                        SkillPrior = inputs.SkillPrior,
                        Name = "TrueSkill"
                    },
                    new OnlineExperiment(ia => new RandomModel(ia), randomParameters1)
                    {
                        Players = inputs.Players,
                        Priors = inputs.TrueSkillPriors,
                        SkillPrior = inputs.SkillPrior,
                        Name = "Random"
                    })
                { Name = "HeadToHead" };

            withoutDraws.AnnounceAndRunAll(gamesWithoutDraws, gamesWithoutDraws.Count);

            var withDraws =
                new OnlineExperimentComparison<TwoPlayerGame>(
                    new OnlineExperiment(ia => new TwoPlayerWithDraws(ia, ShowFactorGraph), trueSkillParameters)
                    {
                        Players = inputs.Players,
                        Priors = inputs.TrueSkillPriors,
                        SkillPrior = inputs.SkillPrior,
                        Name = "TrueSkill"
                    },
                    new OnlineExperiment(ia => new RandomModel(ia), randomParameters2[0])
                    {
                        Players = inputs.Players,
                        Priors = inputs.TrueSkillPriors,
                        SkillPrior = inputs.SkillPrior,
                        Name = "Random"
                    })
                { Name = "HeadToHeadWithDraws" };

            withDraws.AnnounceAndRunAll(inputs);

            var topTwo =
                new OnlineExperimentComparison<TwoPlayerGame>(
                    new OnlineExperiment(ia => new TwoPlayerWithDraws(ia, ShowFactorGraph), trueSkillParameters)
                    {
                        Players = topTwoPlayers,
                        Priors = inputs.TrueSkillPriors,
                        SkillPrior = inputs.SkillPrior,
                        Name = "TrueSkill"
                    });

            topTwo.AnnounceAndRunAll(topTwoGames, topTwoGames.Count);

            outputter.Out(
                withoutDraws,
                Contents.S3ASolutionExpectationPropagation.NumberedName,
                "Halo2-HeadToHead",
                "HeadToHead");

            outputter.Out(
                withoutDraws,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-HeadToHead",
                "HeadToHead");

            outputter.Out(
                withDraws,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-HeadToHead",
                "HeadToHeadWithDraws");


            var headToHeadTopTwo = new Dictionary<string,object>
                {
                    { "Players", topTwoPlayers },
                    { "Games", topTwoGames },
                    { "1v1",
                        topTwo.GetTrajectories(OnlineExperiment.GetTopNPlayersBySkill, Utils.GetMeanAndStandardDeviation, 2)
                            .Where(ia => topTwoPlayers.Contains(ia.Key.Split(' ')[0]) && !ia.Key.Contains("Random")).ToDictionary() },
                    { "1vAll",
                        withDraws.GetTrajectories(OnlineExperiment.GetTopNPlayersBySkill, Utils.GetMeanAndStandardDeviation, int.MaxValue)
                            .Where(ia => topTwoPlayers.Contains(ia.Key.Split(' ')[0]) && !ia.Key.Contains("Random")).ToDictionary() }
                };

            outputter.Out(
                headToHeadTopTwo,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-HeadToHead",
                "HeadToHeadTopTwo");
        }

        /// <summary>
        /// Gets the top two.
        /// </summary>
        /// <param name="inputs">The inputs.</param>
        /// <param name="topTwo">The top two.</param>
        /// <param name="games">The games.</param>
        private void GetTopTwo(Inputs<TwoPlayerGame> inputs, out HashSet<string> topTwo, out IList<TwoPlayerGame> games)
        {
            var ordered = inputs.GameMatrix.OrderByDescending(kvp => kvp.Value.OrderByDescending(inner => inner.Value).First().Value);
            string top1 = ordered.First().Key;
            string top2 = ordered.First().Value.OrderByDescending(kvp => kvp.Value).First().Key;

            topTwo = new HashSet<string> { top1, top2 };

            // Get games between these two players
            games =
                inputs.Games.Where(
                    ia => (ia.Players[0] == top1 && ia.Players[1] == top2) || (ia.Players[0] == top2 && ia.Players[1] == top1)).ToList();
        }

        /// <summary>
        /// Free for all.
        /// </summary>
        public void FreeForAll()
        {
            var inputs = Halo2Fetcher.LoadByGameType<MultiPlayerGame>(Path.Combine(DataPath, "FreeForAll.csv"));

            outputter.Out(inputs,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-FreeForAll",
                "Inputs");

            var datasetSummary =
                new DatasetSummary
                {
                    Name = "Free for All",
                    NumberOfGames = inputs.NumberOfGames,
                    NumberOfPlayers = inputs.NumberOfPlayers,
                    TeamsPerGame = 8,
                    PlayersPerTeam = 1,
                    PlayersPerGame = 8
                };
            outputter.Out(
                datasetSummary,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-FreeForAll",
                "DatasetSummary");

            var freeForAll = this.RunComparison("FreeForAll", (ia, ib, ic) => new MultiPlayer(ia, ib, ic), inputs);
            outputter.Out(freeForAll,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-FreeForAll",
                "ExperimentComparison");
        }

        /// <summary>
        /// The small teams.
        /// </summary>
        public void SmallTeams()
        {
            var inputs = Halo2Fetcher.LoadByGameType<TeamGame>(Path.Combine(DataPath, "SmallTeam.csv"));

            outputter.Out(inputs,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-SmallTeams",
                "Inputs");

            var datasetSummary =
                new DatasetSummary
                {
                    Name = "Small Team",
                    NumberOfGames = inputs.NumberOfGames,
                    NumberOfPlayers = inputs.NumberOfPlayers,
                    TeamsPerGame = 2,
                    PlayersPerTeam = inputs.Games.Average(ia => ia.TeamCounts.Average()),
                    PlayersPerGame = inputs.Games.Average(ia => ia.Players.Count)
                };

            outputter.Out(
                datasetSummary,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-SmallTeams",
                "DatasetSummary");

            var comparison = this.RunComparison("SmallTeams", (ia, ib, ic) => new TwoTeam(ia, ib), inputs);

            outputter.Out(comparison,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-SmallTeams",
                "ExperimentComparison");

            // Take the two players that play the most and add in a player who has played plenty of games but not with another player
            var players = new List<string> { inputs.MaxPlayed[0].Item1, inputs.MaxPlayed[0].Item2, inputs.GameCounts.First().Key };

            // Plots of posteriors for these players
            var posteriors =
                players.Select(
                    p =>
                    new KeyValuePair<string, GaussianPoint[]>(
                        p,
                        comparison.Experiments["TrueSkill"].PlayerPosteriors[p].Select(Utils.GetMeanAndStandardDeviation).ToArray()))
                    .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

            outputter.Out(posteriors,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-SmallTeams",
                "Posteriors");
        }

        /// <summary>
        /// The large teams.
        /// </summary>
        public void LargeTeams()
        {
            var inputs = Halo2Fetcher.LoadByGameType<TeamGame>(Path.Combine(DataPath, "LargeTeam.csv"));

            outputter.Out(inputs,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-LargeTeams",
                "Inputs");

            var datasetSummary =
                new DatasetSummary
                {
                    Name = "Large Team",
                    NumberOfGames = inputs.NumberOfGames,
                    NumberOfPlayers = inputs.NumberOfPlayers,
                    TeamsPerGame = 2,
                    PlayersPerTeam = inputs.Games.Average(ia => ia.TeamCounts.Average()),
                    PlayersPerGame = inputs.Games.Average(ia => ia.Players.Count)
                };

            outputter.Out(datasetSummary,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-LargeTeams",
                "DatasetSummary");

            var largeTeams = this.RunComparison("LargeTeams", (ia, ib, ic) => new TwoTeam(ia, ib), inputs);

            outputter.Out(largeTeams,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "Halo2-LargeTeams",
                "ExperimentComparison");
        }

        /// <summary>
        /// Runs the comparison between TrueSkill and Random models with draws included.
        /// </summary>
        /// <typeparam name="TGame">The type of the game.</typeparam>
        /// <param name="name">The name.</param>
        /// <param name="modelFunc">The model function.</param>
        /// <param name="inputs">The inputs.</param>
        /// <returns>The experiment collection.</returns>
        private OnlineExperimentComparison<TGame> RunComparison<TGame>(string name, Func<IModelParameters, bool, bool, IModel> modelFunc, Inputs<TGame> inputs)
            where TGame : Game
        {

            var randomParameters = new RandomModelParameters
            {
                IncludeDraws = true,
                EmpiricalDrawProportion = inputs.DrawProportion
            };

            var trueSkillParameters = inputs.TrueSkillParameters;
            trueSkillParameters.DynamicsVariance = 0;

            // Remove games with draws.
            var gamesWithoutDraws = inputs.Games.Where(ia => ia is TeamGame && (ia as TeamGame).Outcome != TeamMatchOutcome.Draw).ToList();

            var collection =
                new OnlineExperimentComparison<TGame>(
                    new OnlineExperiment(modelFunc, trueSkillParameters)
                    {
                        Players = inputs.Players,
                        Priors = inputs.TrueSkillPriors,
                        SkillPrior = inputs.SkillPrior,
                        Name = "TrueSkill"
                    },
                    new OnlineExperiment(ia => new RandomModel(ia), randomParameters)
                    {
                        Players = inputs.Players,
                        Priors = inputs.TrueSkillPriors,
                        SkillPrior = inputs.SkillPrior,
                        Name = "Random"
                    })
                { Name = name };

            collection.AnnounceAndRunAll(gamesWithoutDraws, gamesWithoutDraws.Count);
            LogProbs[collection.Name] = collection.CumulativeNegativeLogProbOfTruth;

            return collection;
        }

        /// <summary>
        /// Samples from imaginary game between Jill and Fred
        /// </summary>
        public void JillFredSamples()
        {
            const double Sigma = 40;
            const double Variance = Sigma * Sigma;
            var jill = new Gaussian(120, Variance);
            var fred = new Gaussian(100, Variance);
            var jillFred = new PerformanceSpaceViewModel(jill, fred, 1000) { Player1Name = "Jill", Player2Name = "Fred" };

            // Also compute larger number of samples, but don't plot them
            var bigSamples = PerformanceSpaceViewModel.GenerateSamples(jill, fred, 10000);
            var jillWinProportion = bigSamples.Average(ia => ia.Y > ia.X ? 1.0 : 0.0);

            var probJill = new Gaussian(0, 1).CumulativeDistributionFunction((120 - 100) / Math.Sqrt(2 * Variance));

            Console.WriteLine(@"Probability of Jill winning:");
            Console.WriteLine(@"    Estimate using 1000 samples {0}", jillFred.Player1WinProportion.ToString("P2"));
            Console.WriteLine(@"    Estimate using 10000 samples {0}", jillWinProportion.ToString("P2"));
            Console.WriteLine(@"    Numerical evaluation {0}", probJill.ToString("P2"));
        }

        /// <summary>
        /// The three player toy experiment.
        /// </summary>
        public void ThreePlayerToyExperiment()
        {
            var players = new[] { "Jill", "Fred", "Steve" };
            var scores = new[] { new[] { 2, 1, 0 }, new[] { 1, 2, 0 } };
            var outcomes =
                scores.Select(s => players.Zip(s, (p, score) => new { p, score }).ToDictionary(ia => ia.p, ia => ia.score)).ToArray();

            var inputs = Inputs<MultiPlayerGame>.CreateToyInputs(outcomes);
            outputter.Out(inputs,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "ThreePlayerToyExperiment",
                "Inputs");

            // Rerun first game with different variances
            var priors = new Priors
            {
                Skills =
                                      {
                                          { "Jill", new Gaussian(120, 400) },
                                          { "Fred", new Gaussian(100, inputs.InitialVariance) },
                                          { "Steve", new Gaussian(140, inputs.InitialVariance) }
                                      }
            };


            var model = new MultiPlayer(inputs.TrueSkillParameters, ShowFactorGraph);
            var threePlayerToyExperiment = new[]
                                                             {
                                                                 new ToyExperiment(model, inputs.Games[0], priors),
                                                                 new ToyExperiment(model, inputs.Games[1], priors)
                                                             };

            outputter.Out(threePlayerToyExperiment,
                Contents.S4ExtensionsToTheCoreModel.NumberedName,
                "ThreePlayerToyExperiment",
                "Experiments");
        }

        /// <summary>
        /// Demonstration of Dynamics.
        /// </summary>
        /// <param name="trueBeta">The true beta.</param>
        /// <param name="beta">The beta.</param>
        /// <param name="stepSize">Size of the step.</param>
        public void DynamicsDemo(double trueBeta, double beta, double stepSize)
        {
            var randomNames = new RandomNameGenerator(0, int.MaxValue, true);

            var players = new HashSet<string>(randomNames.Take(100));
            string improver = players.First();

            const double Mu = 125;
            const double Sigma = 10;
            var skillDistribution = new Gaussian(Mu, Sigma * Sigma);
            const double Gamma = 0.4;


            const double SkillStart = 110;
            const double SkillMax = 140;

            var inputs1 = new Inputs<TwoPlayerGame> { Mu = Mu, Sigma = Sigma, Beta = beta, Gamma = 0 };
            var inputs2 = new Inputs<TwoPlayerGame> { Mu = Mu, Sigma = Sigma, Beta = beta, Gamma = Gamma };

            double truePerformanceVariance = trueBeta * trueBeta;

            // number of games
            const int NumberOfGames = 25000;

            var skill1 = Gaussian.PointMass(SkillStart);

            var random = new Random(0);

            var initialSkills = players.ToDictionary(ia => ia, ia => Gaussian.PointMass(skillDistribution.Sample()));
            initialSkills[improver] = skill1;

            var trueSkills = new Dictionary<string, List<double>> { { improver, new List<double>() } };
            for (int i = 0; i < NumberOfGames; i++)
            {
                // Pick two players to play game
                var gamePlayers = players.OrderBy(ia => random.Next()).Take(2).ToList();

                // update improver's skill
                var truth = new Marginals { Skills = new Dictionary<string, Gaussian>(initialSkills) };
                truth.Skills[improver] = skill1;

                // Generate game according to truth
                var game = TwoPlayerVaryingSkills.Sample(truth, gamePlayers, truePerformanceVariance);
                inputs1.Games.Add(game);
                inputs2.Games.Add(game);

                if (gamePlayers.Contains(improver))
                {
                    trueSkills[improver].Add(skill1.Point);

                    // Update skill
                    if (trueSkills[improver].Count > 100 && (trueSkills[improver].Count % 100) >= 90 && skill1.Point < SkillMax)
                    {
                        skill1 = Gaussian.PointMass(skill1.Point + stepSize);
                    }
                }
            }

            var experiment1 = new OnlineExperiment(ia => new TwoPlayerVaryingSkills(ia, ShowFactorGraph), inputs1.TrueSkillParameters)
            {
                Players = players,
                Priors = inputs1.TrueSkillPriors,
                Name = "Fixed skill model"
            };

            var experiment2 = new OnlineExperiment(ia => new TwoPlayerVaryingSkills  (ia, ShowFactorGraph), inputs2.TrueSkillParameters)
            {
                Players = players,
                Priors = inputs2.TrueSkillPriors,
                Name = "Varying skill model"
            };

            AnnounceExperiment(experiment1.Name);
            experiment1.Run(inputs1.Games, inputs1.Games.Count, false);
            AnnounceExperiment(experiment2.Name);
            experiment2.Run(inputs2.Games, inputs2.Games.Count, false);

            var experiments1 = new OnlineExperimentComparison<TwoPlayerGame>(experiment1) { Truth = trueSkills };
            var experiments2 = new OnlineExperimentComparison<TwoPlayerGame>(experiment2) { Truth = trueSkills };

            var initialSkillsTable =
                initialSkills.OrderByDescending(ia => ia.Key)
                    .ToDictionaryForTable<KeyValuePair<string, Gaussian>, string, double, double>(
                        ia => ia.Key,
                        new Dictionary<string, Func<KeyValuePair<string, Gaussian>, double>> { { "Skill", g => g.Value.Point } },
                        false,
                        null,
                        "Player");

            var collection = new OnlineExperimentComparison<TwoPlayerGame>(experiment1, experiment2) { Truth = trueSkills };

            var dynamicsDemo = new Dictionary<string,object>
                             {
                                 { "InitialSkills", initialSkillsTable },
                                 { "SampledInputs", inputs1 },
                                 {
                                     "Trajectories",
                                     new[]
                                         {
                                             experiments1.PlayerTrajectoriesWithSigmaAndTruth,
                                             experiments2.PlayerTrajectoriesWithSigmaAndTruth,
                                             collection.PlayerTrajectoriesWithSigmaAndTruth
                                         }
                                 }
                             };

            outputter.Out(dynamicsDemo,
                Contents.S5AllowingTheSkillsToVary.NumberedName,
                "DynamicsDemo");
        }

        /// <summary>
        /// The dataset summary.
        /// </summary>
        public class DatasetSummary
        {
            /// <summary>
            /// Saves the results.
            /// </summary>
#if NETFULL
            [CommandInformation(DisplayText = "Save Result", ShowInContextMenu = true, ShowInToolbar = true)]
#endif
            public void SaveResults()
            {

                FileUtils.Save(DataPath, this.Name, this);
            }

            /// <summary>
            /// Gets or sets the name.
            /// </summary>
            public string Name { get; set; }

            /// <summary>
            /// Gets or sets the number of players.
            /// </summary>
            public int NumberOfPlayers { get; set; }

            /// <summary>
            /// Gets or sets the number of games.
            /// </summary>
            public int NumberOfGames { get; set; }

            /// <summary>
            /// Gets or sets the teams per game.
            /// </summary>
            public int TeamsPerGame { get; set; }

            /// <summary>
            /// Gets or sets the players per team.
            /// </summary>
            public double PlayersPerTeam { get; set; }

            /// <summary>
            /// Gets or sets the players per game.
            /// </summary>
            public double PlayersPerGame { get; set; }
        }
    }
}
